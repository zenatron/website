---
title: "How I Built My MDX Blog System (and Why It’s Fast Enough)"
date: "2025-02-21"
readingTime: "16min"
excerpt: "A behind‑the‑scenes look at how my MDX pipeline works, how I render posts, and where performance really matters."
tags: ["mdx", "nextjs", "performance", "web-dev"]
---

import Callout from '@/components/mdx/Callout';

# How I Built My MDX Blog System (and Why It’s Fast Enough)

I wanted a blog that felt like **[Markdown](https://en.wikipedia.org/wiki/Markdown)**, but could still render React components, callouts, and embeds without turning into a templating mess. **[MDX](https://en.wikipedia.org/wiki/MDX_(markdown))** hit the sweet spot.

![MDX pipeline diagram](/images/blog/how-this-mdx-blog-works/mdx-pipeline.svg)
![MDX compilation flow diagram](/images/blog/how-this-mdx-blog-works/compile-flow.svg)

## Why MDX (not just Markdown)

Markdown is simple and portable. The downside: you’re stuck with plain content. MDX gives you the ability to **import React components** right inside a post, which means you can drop in things like callouts, counters, or custom embeds. Under the hood, MDX turns your content into a structured syntax tree (think **[AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree)**) before it becomes React.

If you’ve used a static site generator before, MDX feels like “Markdown with superpowers” — but it’s still readable in plain text, which keeps the writing workflow fast.

Example:

```mdx
import Callout from '@/components/mdx/Callout';

<Callout type="info" title="Quick tip">
  This is an MDX component rendered inside your post.
</Callout>
```

## The pipeline: files → frontmatter → compiled content

At a high level, my posts live in `src/content/blog/*.mdx`. When a blog page is requested, the site:

1. **Reads the file** from disk
2. **Parses [front matter](https://en.wikipedia.org/wiki/YAML#Front_matter)** with `gray-matter`
3. **Compiles MDX** using `next-mdx-remote`
4. **Runs a remark/rehype pipeline** (Markdown → HTML) for math, tables, syntax highlighting, and heading slugs

This happens in the `getBlogPostBySlug` function and `getAllBlogPosts` list builder.

The key point: the MDX compilation happens on the server, not in the browser. That means visitors aren’t shipping a Markdown parser to render your content — they get clean HTML.

Helpful references:

- [next-mdx-remote](https://github.com/hashicorp/next-mdx-remote)
- [remark-gfm](https://github.com/remarkjs/remark-gfm)
- [rehype-highlight](https://github.com/rehypejs/rehype-highlight)
- [remark](https://github.com/remarkjs/remark)
- [rehype](https://github.com/rehypejs/rehype)

## Table of contents + searchability

I wanted a TOC on every post and quick search on the blog index. So I added two features:

- **Heading extraction** for a table of contents (I parse raw Markdown headings so the TOC is stable and predictable)
- **Plain‑text extraction** for search (strip imports, JSX, code blocks, then index the result)

The TOC uses `rehype-slug` to ensure headings have predictable IDs, which is why the anchor links stay stable across builds.

<Callout type="note" title="Tiny performance win" showEmoji={true}>
Doing those extra passes once during compilation keeps the client UI lightweight.
</Callout>

## Styling: a focused MDX layer

All post content is wrapped in `.mdx-content`, with typography and media styles in `src/app/markdown.css`. That means:

- Code blocks look good without extra wrappers
- Tables are readable
- Images and iframes are responsive by default

Because the styles are centralized in a single file, I can tweak typography without editing every post. That’s a small thing that pays off over time.

## Components I actually use in posts

Right now I keep it simple:

- **Callouts** for tips, warnings, and side notes.
- **Embeds** for videos and live demos.
- **Custom code blocks** with syntax highlighting.

The constraint is intentional: fewer components means fewer ways for content to break over time.

## Performance: where it matters (and where it doesn’t)

The two main performance costs are:

1. **Compilation time** – MDX compilation is expensive compared to plain Markdown.
2. **List page aggregation** – the blog index compiles every post so it can render excerpts, tags, and searchable text.
3. **Syntax highlighting** – code highlighting adds overhead, but it keeps posts readable for technical content.

If I ever hit scaling issues, the next step would be **pre‑compiling** MDX into cached artifacts at build time and only re‑compiling changed posts.

In practice, this is fine for a small‑to‑mid sized blog. If I were scaling to hundreds of posts, I’d pre‑compile content or cache compiled output.

## Rendering model (why the page still feels snappy)

The heavy lifting happens on the server. By the time the browser gets the page, the MDX is already rendered into HTML and styled by the `.mdx-content` layer. That’s classic **[server‑side rendering](https://en.wikipedia.org/wiki/Server-side_scripting)**: the client only needs to display the result, not compile it.

## The parts I don’t want to compromise on

- **Readable source files** (writing should feel like writing, not coding).
- **Composable components** (callouts, embeds, and custom UI).
- **Plain SEO‑friendly HTML** on the other side.

MDX checks all three boxes for me.

## Measuring performance (lightweight but honest)

I keep an eye on:

- Build time (does compiling all posts start to drag?)
- Page load on mobile (do embeds slow things down?)
- Core Web Vitals for individual posts

If any of those start to slip, I’ll adjust the pipeline rather than throwing more JS at the browser.

<Callout type="info" title="Why I’m okay with it" showEmoji={true}>
For my current post volume, build‑time compilation is a trade‑off I’m happy with: simpler code, fewer moving parts, and no extra build pipeline.
</Callout>

## What I’d improve next

- **Incremental compilation** (only rebuild changed posts)
- **Prebuilt search index** for faster client filtering
- **Image optimization** with metadata (width/height) for layout stability

## A note on images and embeds

Images live in `public/images/blog/...`, which keeps paths stable and makes them easy to reference from MDX. For videos, I use responsive `<iframe>` embeds that inherit the `.mdx-content` styling so they don’t overflow the layout on small screens.

## A quick video that inspired the approach

<iframe
  title="MDX in Next.js"
  src="https://www.youtube.com/embed/1B0d9QwCw1o"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
  allowFullScreen
></iframe>

## Examples you can read next

- [What Is a VPN?](/blog/what-is-a-vpn)
- [Tailscale Explained](/blog/tailscale-explained)
- [Self‑Hosting With Tailscale](/blog/self-hosting-with-tailscale)

If you’re building your own MDX pipeline and want to compare notes, I’m happy to share more details.
